/*
 * RFM_26.h
 * Driver for the RFM26 module (Si4463) based on the libopencm3 HAL
 *
 * This driver offers some basic functions to send and transmit packets with a RFM26 module
 * using the built-in packet handler of the RFM module.
 * Most of the RF specific options must be set in the module config generated by Silicon Labs WDS util.
 *
 * Data transmission and reception is done synchronous, so the functions will wait until the operation
 * is complete or an error / timeout occures.
 * In order to not miss any incoming data, the tx_packet function should be called often enough.
 *
 * Current limmitations:
 *   - Fixed packet size
 *   - Whole packet must fit into the RFM's RX FIFO
 *   - Static configuration by pre-generated config
 *   - No asynchonous mode
 *   - Requires the RFM's CTS signal to be connected to the MCU
 *
 * If not specified otherwise, all functions return a value form the RFM_RESULT enum
 */

#include <stdint.h>

enum RFM_RESULT
{
	RFM_RES_OK,                   // Operation finished successfully
	RFM_RES_HAL_ERROR,            // HAL layer reports an error
	RFM_RES_NOT_RESPONDING,       // No response from RFM module
	RFM_RES_CTS_MISSING,          // Missing CTS in response
	RFM_RES_UNEXPECTED_RESPONSE,  // RFM response is unexpected
	RFM_RES_RX_WRONGSIZE,         // Wrong size of received packet
	RFM_RES_RX_TIMEOUT,           // No packet received in given time
	RFM_RES_TX_BUSY,              // The module is busy (currently receiving data)
	RFM_RES_TX_TIMEOUT            // TX operation did not finish before timeout
};

/*
 * Initializes the driver and the RFM module.
 * This also checks, if the module responds as expected
 */
uint8_t RFM_driver_init(void);

/*
 * Completely re-initializes the RFM module
 */
uint8_t RFM_module_reset(void);


/*
 * Receives a packet
 * This function waits for a packet or for <timeout> ticks until returning.
 * If the clear_fifo bit is set, the rx fifo will be cleared before receiving data.
 *  -> A received packet will always be fresh.
 *
 * NOTE:
 * The RFM module will always be in the RX state unless a transmission is currently ongoing,
 * so it will still receive data, even if rx_packet is not currently executed.
 */
uint8_t RFM_rx_packet(void *packet, uint32_t timeout, uint8_t clear_fifo);


/*
 * Sends a packet
 * Before entering the send mode, this function checks, if the module is currently receiving data.
 * If so, this function will fail with a TX_BUSY.
 */
uint8_t RFM_tx_packet(const void *packet);

/*
 * Sends a raw command to the RFM module and returns the result
 * This command is primary intended for testing and debugging
 * result and result_size may be 0
 */
uint8_t RFM_raw_cmd(const void *cmd, uint32_t cmd_size, void *result, uint32_t result_size);

/*
 * Test function REMOVE THIS
 * */
//uint8_t RFM_test();
